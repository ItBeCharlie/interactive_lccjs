# LCC.js
LCC.js is a JavaScript implementation of a simple assembler and interpreter for a virtual assembly language and machine architecture inspired by educational projects like the Low Cost Computer (LCC) by Professor Anthony Dos Reis. The goal of LCC.js is to provide a learning tool for understanding the fundamentals of assembly language programming, machine code generation, and instruction execution in a high-level programming language environment.

## Goals
- **Educational Purpose**: Serve as a learning resource for students and enthusiasts to understand how assemblers and interpreters work at a fundamental level.
- **JavaScript Implementation**: Leverage the ubiquity and accessibility of JavaScript to make the tool widely available without the need for specialized compilers or environments.
- **Feature Parity with Original LCC**: Aim to replicate the functionality of the original LCC assembler and interpreter while providing modern conveniences and coding practices.
- **Cross-Platform Compatibility**: Ensure that the tool works consistently across different operating systems (Windows, macOS, Linux) by using Node.js.

## Differences from LCC
- **Programming Language**: LCC.js is implemented in JavaScript using Node.js, whereas the original LCC is typically implemented in C.
- **Platform Independence**: Runs on any platform that supports Node.js, eliminating the need for platform-specific binaries or compilers.
- **Ease of Use**: Simplifies execution by using command-line scripts without the need for compilation steps.

## Components
- **lcc.js**: Main program that combines assembling and interpreting. **Recommended** way to compile and run your assembly code.
- **Assembler (assembler.js)**: Translates assembly language source code into machine code executable files with a `.e` extension.
- **Interpreter (interpreter.js)**: Executes the machine code files generated by the assembler, simulating the behavior of the virtual machine architecture.

## Usage Instructions

### Prerequisites

- **Node.js**: Ensure that Node.js is installed on your system. You can download it from [nodejs.org](https://nodejs.org/).

### Compiling and Running Source Code with lcc.js (Recommended)

To assemble and execute an assembly language source file (e.g., `program.a`) in one step:

```bash
node lcc.js program.a
```

This command will assemble `program.a`, produce an executable file `program.e`, execute it, and generate ~~(`.lst` and)~~ `.bst` files.

#### Example
Compile and run `demoB.a`:

```bash
node lcc.js demoB.a
```

### Assembling Source Code Separately
To assemble an assembly language source file without executing it:

```bash
node assembler.js program.a
```

This command will produce an executable file named `program.e` in the same directory.

#### Example
Assemble a1test.a:

```bash
node assembler.js a1test.a
```

### Running the Interpreter
To execute the assembled machine code file using the interpreter:

```bash
node interpreter.js program.e
```

#### Example
Run a1test.e:

```bash
node interpreter.js a1test.e
```

### Output
When you run the interpreter with an executable file, it will display:

- The author's name (placeholder in the code as FIRSTNAME LASTNAME).
- The interpreter script name.
- The input file name.
- The current date and time.
- The output generated by the executed program.

Sample Output
```diff
LASTNAME, FIRSTNAME     interpreter.js a1test.e     Thu Oct 26 2023 12:34:56 GMT-0400 (Eastern Daylight Time)
1
2
3
4
5
6
7
8
-9
-10
-11
-12
```

## File Descriptions
### lcc.js
- **Purpose**: The main program that orchestrates assembling and interpreting. It determines the file type based on the extension and performs the appropriate actions.
- **Usage**: node lcc.js <input_file>
- **Features**:
  - Automatically assembles .a files and then executes them.
  - Can execute pre-assembled .e, .hex, or .bin files.
  - Generates .lst and .bst files with detailed listings and outputs.
### assembler.js
- **Purpose**: Reads assembly language source files, processes them in two passes to handle symbol definitions and instructions, and outputs machine code executable files.
- **Usage**: node assembler.js <source_file>
- **Features**:
  - Handles labels, directives (e.g., .zero, .word), and instructions.
  - Performs error checking with detailed messages and line numbers.
  - Writes machine code directly to the output file during Pass 2.
### interpreter.js
- **Purpose**: Loads machine code executable files into memory and simulates the execution of instructions on a virtual machine architecture.
- **Usage**: node interpreter.js <executable_file>
- **Features**:
  - Simulates registers, memory, and flags (negative, zero, carry, overflow).
  - Supports a set of instructions including arithmetic, logical, control flow, and trap routines.
  - Outputs the results of the executed program to the console.

## Understanding the Architecture
The virtual machine architecture includes:

- **Registers**: Eight general-purpose registers (r0 to r7), each 16 bits wide.
- **Memory**: 65,536 words of memory (16-bit words).
- **Instruction Set**: A set of instructions with opcodes for operations like ADD, AND, LD, ST, BR, JMP, etc.
- **Flags**: Negative (N), Zero (Z), Carry (C), and Overflow (V) flags affected by certain operations.

## Extending LCC.js
You can extend LCC.js by:

- **Adding New Instructions**: Modify the assembler and interpreter to recognize and handle new opcodes and instruction formats.
- **Enhancing Error Handling**: Improve the feedback provided to users when assembly or runtime errors occur.
- **Building a Debugger**: Implement features to step through instructions, inspect registers and memory, and set breakpoints.

## Conclusion
LCC.js provides a practical way to explore low-level programming concepts using high-level languages. By assembling and interpreting assembly code, users can gain insights into how compilers and processors handle code execution, making it a valuable educational tool.

## License
This project is provided for educational purposes and does not include any warranty. Use it at your own risk.

## Disclaimer
The author's name in the output is a placeholder (LASTNAME, FIRSTNAME). Replace it with the appropriate name if needed.

## Contact
For questions or contributions, please open an issue or submit a pull request on the project's repository.